// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_algo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_5falgo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_5falgo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_5falgo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_5falgo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_5falgo_2eproto;
class SignalServerConfigProto;
struct SignalServerConfigProtoDefaultTypeInternal;
extern SignalServerConfigProtoDefaultTypeInternal _SignalServerConfigProto_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class Wrapper;
struct WrapperDefaultTypeInternal;
extern WrapperDefaultTypeInternal _Wrapper_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::SignalServerConfigProto* Arena::CreateMaybeMessage<::SignalServerConfigProto>(Arena*);
template<> ::Status* Arena::CreateMaybeMessage<::Status>(Arena*);
template<> ::Wrapper* Arena::CreateMaybeMessage<::Wrapper>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Wrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Wrapper) */ {
 public:
  inline Wrapper() : Wrapper(nullptr) {}
  ~Wrapper() override;
  explicit PROTOBUF_CONSTEXPR Wrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wrapper(const Wrapper& from);
  Wrapper(Wrapper&& from) noexcept
    : Wrapper() {
    *this = ::std::move(from);
  }

  inline Wrapper& operator=(const Wrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wrapper& operator=(Wrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wrapper& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSignalServerConfig = 1,
    kStatus = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Wrapper* internal_default_instance() {
    return reinterpret_cast<const Wrapper*>(
               &_Wrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Wrapper& a, Wrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(Wrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Wrapper& from) {
    Wrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Wrapper";
  }
  protected:
  explicit Wrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalServerConfigFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .SignalServerConfigProto signal_server_config = 1;
  bool has_signal_server_config() const;
  private:
  bool _internal_has_signal_server_config() const;
  public:
  void clear_signal_server_config();
  const ::SignalServerConfigProto& signal_server_config() const;
  PROTOBUF_NODISCARD ::SignalServerConfigProto* release_signal_server_config();
  ::SignalServerConfigProto* mutable_signal_server_config();
  void set_allocated_signal_server_config(::SignalServerConfigProto* signal_server_config);
  private:
  const ::SignalServerConfigProto& _internal_signal_server_config() const;
  ::SignalServerConfigProto* _internal_mutable_signal_server_config();
  public:
  void unsafe_arena_set_allocated_signal_server_config(
      ::SignalServerConfigProto* signal_server_config);
  ::SignalServerConfigProto* unsafe_arena_release_signal_server_config();

  // .Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::Status& status() const;
  PROTOBUF_NODISCARD ::Status* release_status();
  ::Status* mutable_status();
  void set_allocated_status(::Status* status);
  private:
  const ::Status& _internal_status() const;
  ::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::Status* status);
  ::Status* unsafe_arena_release_status();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Wrapper)
 private:
  class _Internal;
  void set_has_signal_server_config();
  void set_has_status();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SignalServerConfigProto* signal_server_config_;
      ::Status* status_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_5falgo_2eproto;
};
// -------------------------------------------------------------------

class SignalServerConfigProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SignalServerConfigProto) */ {
 public:
  inline SignalServerConfigProto() : SignalServerConfigProto(nullptr) {}
  ~SignalServerConfigProto() override;
  explicit PROTOBUF_CONSTEXPR SignalServerConfigProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalServerConfigProto(const SignalServerConfigProto& from);
  SignalServerConfigProto(SignalServerConfigProto&& from) noexcept
    : SignalServerConfigProto() {
    *this = ::std::move(from);
  }

  inline SignalServerConfigProto& operator=(const SignalServerConfigProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalServerConfigProto& operator=(SignalServerConfigProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalServerConfigProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalServerConfigProto* internal_default_instance() {
    return reinterpret_cast<const SignalServerConfigProto*>(
               &_SignalServerConfigProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignalServerConfigProto& a, SignalServerConfigProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalServerConfigProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalServerConfigProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalServerConfigProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalServerConfigProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalServerConfigProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalServerConfigProto& from) {
    SignalServerConfigProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalServerConfigProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SignalServerConfigProto";
  }
  protected:
  explicit SignalServerConfigProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRxHeightsFieldNumber = 8,
    kSdfDirectoryFieldNumber = 1,
    kOutputFileFieldNumber = 2,
    kUserTerrainFileFieldNumber = 3,
    kTerrainBackgroundFieldNumber = 4,
    kLatitudeFieldNumber = 5,
    kLongitudeFieldNumber = 6,
    kTxHeightFieldNumber = 7,
    kFrequencyMhzFieldNumber = 9,
    kErpWattsFieldNumber = 10,
    kRxThresholdFieldNumber = 11,
    kGroundClutterFieldNumber = 13,
    kTerrainDielectricFieldNumber = 15,
    kTerrainCodeFieldNumber = 14,
    kClimateCodeFieldNumber = 17,
    kTerrainConductivityFieldNumber = 16,
    kPropagationModelFieldNumber = 18,
    kHorizontalPolFieldNumber = 12,
    kKnifeEdgeDiffFieldNumber = 19,
    kWin32TileNamesFieldNumber = 20,
    kDebugModeFieldNumber = 21,
    kMetricUnitsFieldNumber = 22,
    kPlotDbmFieldNumber = 23,
    kResolutionFieldNumber = 25,
    kRadiusFieldNumber = 24,
  };
  // repeated double rx_heights = 8;
  int rx_heights_size() const;
  private:
  int _internal_rx_heights_size() const;
  public:
  void clear_rx_heights();
  private:
  double _internal_rx_heights(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_rx_heights() const;
  void _internal_add_rx_heights(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_rx_heights();
  public:
  double rx_heights(int index) const;
  void set_rx_heights(int index, double value);
  void add_rx_heights(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      rx_heights() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_rx_heights();

  // string sdf_directory = 1;
  void clear_sdf_directory();
  const std::string& sdf_directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdf_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdf_directory();
  PROTOBUF_NODISCARD std::string* release_sdf_directory();
  void set_allocated_sdf_directory(std::string* sdf_directory);
  private:
  const std::string& _internal_sdf_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdf_directory(const std::string& value);
  std::string* _internal_mutable_sdf_directory();
  public:

  // string output_file = 2;
  void clear_output_file();
  const std::string& output_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_file();
  PROTOBUF_NODISCARD std::string* release_output_file();
  void set_allocated_output_file(std::string* output_file);
  private:
  const std::string& _internal_output_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_file(const std::string& value);
  std::string* _internal_mutable_output_file();
  public:

  // optional string user_terrain_file = 3;
  bool has_user_terrain_file() const;
  private:
  bool _internal_has_user_terrain_file() const;
  public:
  void clear_user_terrain_file();
  const std::string& user_terrain_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_terrain_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_terrain_file();
  PROTOBUF_NODISCARD std::string* release_user_terrain_file();
  void set_allocated_user_terrain_file(std::string* user_terrain_file);
  private:
  const std::string& _internal_user_terrain_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_terrain_file(const std::string& value);
  std::string* _internal_mutable_user_terrain_file();
  public:

  // optional string terrain_background = 4;
  bool has_terrain_background() const;
  private:
  bool _internal_has_terrain_background() const;
  public:
  void clear_terrain_background();
  const std::string& terrain_background() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_terrain_background(ArgT0&& arg0, ArgT... args);
  std::string* mutable_terrain_background();
  PROTOBUF_NODISCARD std::string* release_terrain_background();
  void set_allocated_terrain_background(std::string* terrain_background);
  private:
  const std::string& _internal_terrain_background() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terrain_background(const std::string& value);
  std::string* _internal_mutable_terrain_background();
  public:

  // double latitude = 5;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 6;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // double tx_height = 7;
  void clear_tx_height();
  double tx_height() const;
  void set_tx_height(double value);
  private:
  double _internal_tx_height() const;
  void _internal_set_tx_height(double value);
  public:

  // double frequency_mhz = 9;
  void clear_frequency_mhz();
  double frequency_mhz() const;
  void set_frequency_mhz(double value);
  private:
  double _internal_frequency_mhz() const;
  void _internal_set_frequency_mhz(double value);
  public:

  // double erp_watts = 10;
  void clear_erp_watts();
  double erp_watts() const;
  void set_erp_watts(double value);
  private:
  double _internal_erp_watts() const;
  void _internal_set_erp_watts(double value);
  public:

  // optional double rx_threshold = 11;
  bool has_rx_threshold() const;
  private:
  bool _internal_has_rx_threshold() const;
  public:
  void clear_rx_threshold();
  double rx_threshold() const;
  void set_rx_threshold(double value);
  private:
  double _internal_rx_threshold() const;
  void _internal_set_rx_threshold(double value);
  public:

  // optional double ground_clutter = 13;
  bool has_ground_clutter() const;
  private:
  bool _internal_has_ground_clutter() const;
  public:
  void clear_ground_clutter();
  double ground_clutter() const;
  void set_ground_clutter(double value);
  private:
  double _internal_ground_clutter() const;
  void _internal_set_ground_clutter(double value);
  public:

  // optional double terrain_dielectric = 15;
  bool has_terrain_dielectric() const;
  private:
  bool _internal_has_terrain_dielectric() const;
  public:
  void clear_terrain_dielectric();
  double terrain_dielectric() const;
  void set_terrain_dielectric(double value);
  private:
  double _internal_terrain_dielectric() const;
  void _internal_set_terrain_dielectric(double value);
  public:

  // optional int32 terrain_code = 14;
  bool has_terrain_code() const;
  private:
  bool _internal_has_terrain_code() const;
  public:
  void clear_terrain_code();
  int32_t terrain_code() const;
  void set_terrain_code(int32_t value);
  private:
  int32_t _internal_terrain_code() const;
  void _internal_set_terrain_code(int32_t value);
  public:

  // optional int32 climate_code = 17;
  bool has_climate_code() const;
  private:
  bool _internal_has_climate_code() const;
  public:
  void clear_climate_code();
  int32_t climate_code() const;
  void set_climate_code(int32_t value);
  private:
  int32_t _internal_climate_code() const;
  void _internal_set_climate_code(int32_t value);
  public:

  // optional double terrain_conductivity = 16;
  bool has_terrain_conductivity() const;
  private:
  bool _internal_has_terrain_conductivity() const;
  public:
  void clear_terrain_conductivity();
  double terrain_conductivity() const;
  void set_terrain_conductivity(double value);
  private:
  double _internal_terrain_conductivity() const;
  void _internal_set_terrain_conductivity(double value);
  public:

  // int32 propagation_model = 18;
  void clear_propagation_model();
  int32_t propagation_model() const;
  void set_propagation_model(int32_t value);
  private:
  int32_t _internal_propagation_model() const;
  void _internal_set_propagation_model(int32_t value);
  public:

  // optional bool horizontal_pol = 12;
  bool has_horizontal_pol() const;
  private:
  bool _internal_has_horizontal_pol() const;
  public:
  void clear_horizontal_pol();
  bool horizontal_pol() const;
  void set_horizontal_pol(bool value);
  private:
  bool _internal_horizontal_pol() const;
  void _internal_set_horizontal_pol(bool value);
  public:

  // optional bool knife_edge_diff = 19;
  bool has_knife_edge_diff() const;
  private:
  bool _internal_has_knife_edge_diff() const;
  public:
  void clear_knife_edge_diff();
  bool knife_edge_diff() const;
  void set_knife_edge_diff(bool value);
  private:
  bool _internal_knife_edge_diff() const;
  void _internal_set_knife_edge_diff(bool value);
  public:

  // optional bool win32_tile_names = 20;
  bool has_win32_tile_names() const;
  private:
  bool _internal_has_win32_tile_names() const;
  public:
  void clear_win32_tile_names();
  bool win32_tile_names() const;
  void set_win32_tile_names(bool value);
  private:
  bool _internal_win32_tile_names() const;
  void _internal_set_win32_tile_names(bool value);
  public:

  // optional bool debug_mode = 21;
  bool has_debug_mode() const;
  private:
  bool _internal_has_debug_mode() const;
  public:
  void clear_debug_mode();
  bool debug_mode() const;
  void set_debug_mode(bool value);
  private:
  bool _internal_debug_mode() const;
  void _internal_set_debug_mode(bool value);
  public:

  // optional bool metric_units = 22;
  bool has_metric_units() const;
  private:
  bool _internal_has_metric_units() const;
  public:
  void clear_metric_units();
  bool metric_units() const;
  void set_metric_units(bool value);
  private:
  bool _internal_metric_units() const;
  void _internal_set_metric_units(bool value);
  public:

  // optional bool plot_dbm = 23;
  bool has_plot_dbm() const;
  private:
  bool _internal_has_plot_dbm() const;
  public:
  void clear_plot_dbm();
  bool plot_dbm() const;
  void set_plot_dbm(bool value);
  private:
  bool _internal_plot_dbm() const;
  void _internal_set_plot_dbm(bool value);
  public:

  // int32 resolution = 25;
  void clear_resolution();
  int32_t resolution() const;
  void set_resolution(int32_t value);
  private:
  int32_t _internal_resolution() const;
  void _internal_set_resolution(int32_t value);
  public:

  // double radius = 24;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:SignalServerConfigProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > rx_heights_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdf_directory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_file_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_terrain_file_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr terrain_background_;
    double latitude_;
    double longitude_;
    double tx_height_;
    double frequency_mhz_;
    double erp_watts_;
    double rx_threshold_;
    double ground_clutter_;
    double terrain_dielectric_;
    int32_t terrain_code_;
    int32_t climate_code_;
    double terrain_conductivity_;
    int32_t propagation_model_;
    bool horizontal_pol_;
    bool knife_edge_diff_;
    bool win32_tile_names_;
    bool debug_mode_;
    bool metric_units_;
    bool plot_dbm_;
    int32_t resolution_;
    double radius_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_5falgo_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeStatusFieldNumber = 1,
  };
  // string type_status = 1;
  void clear_type_status();
  const std::string& type_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type_status();
  PROTOBUF_NODISCARD std::string* release_type_status();
  void set_allocated_type_status(std::string* type_status);
  private:
  const std::string& _internal_type_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_status(const std::string& value);
  std::string* _internal_mutable_type_status();
  public:

  // @@protoc_insertion_point(class_scope:Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_5falgo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Wrapper

// .SignalServerConfigProto signal_server_config = 1;
inline bool Wrapper::_internal_has_signal_server_config() const {
  return payload_case() == kSignalServerConfig;
}
inline bool Wrapper::has_signal_server_config() const {
  return _internal_has_signal_server_config();
}
inline void Wrapper::set_has_signal_server_config() {
  _impl_._oneof_case_[0] = kSignalServerConfig;
}
inline void Wrapper::clear_signal_server_config() {
  if (_internal_has_signal_server_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.signal_server_config_;
    }
    clear_has_payload();
  }
}
inline ::SignalServerConfigProto* Wrapper::release_signal_server_config() {
  // @@protoc_insertion_point(field_release:Wrapper.signal_server_config)
  if (_internal_has_signal_server_config()) {
    clear_has_payload();
    ::SignalServerConfigProto* temp = _impl_.payload_.signal_server_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.signal_server_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SignalServerConfigProto& Wrapper::_internal_signal_server_config() const {
  return _internal_has_signal_server_config()
      ? *_impl_.payload_.signal_server_config_
      : reinterpret_cast< ::SignalServerConfigProto&>(::_SignalServerConfigProto_default_instance_);
}
inline const ::SignalServerConfigProto& Wrapper::signal_server_config() const {
  // @@protoc_insertion_point(field_get:Wrapper.signal_server_config)
  return _internal_signal_server_config();
}
inline ::SignalServerConfigProto* Wrapper::unsafe_arena_release_signal_server_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Wrapper.signal_server_config)
  if (_internal_has_signal_server_config()) {
    clear_has_payload();
    ::SignalServerConfigProto* temp = _impl_.payload_.signal_server_config_;
    _impl_.payload_.signal_server_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_signal_server_config(::SignalServerConfigProto* signal_server_config) {
  clear_payload();
  if (signal_server_config) {
    set_has_signal_server_config();
    _impl_.payload_.signal_server_config_ = signal_server_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Wrapper.signal_server_config)
}
inline ::SignalServerConfigProto* Wrapper::_internal_mutable_signal_server_config() {
  if (!_internal_has_signal_server_config()) {
    clear_payload();
    set_has_signal_server_config();
    _impl_.payload_.signal_server_config_ = CreateMaybeMessage< ::SignalServerConfigProto >(GetArenaForAllocation());
  }
  return _impl_.payload_.signal_server_config_;
}
inline ::SignalServerConfigProto* Wrapper::mutable_signal_server_config() {
  ::SignalServerConfigProto* _msg = _internal_mutable_signal_server_config();
  // @@protoc_insertion_point(field_mutable:Wrapper.signal_server_config)
  return _msg;
}

// .Status status = 2;
inline bool Wrapper::_internal_has_status() const {
  return payload_case() == kStatus;
}
inline bool Wrapper::has_status() const {
  return _internal_has_status();
}
inline void Wrapper::set_has_status() {
  _impl_._oneof_case_[0] = kStatus;
}
inline void Wrapper::clear_status() {
  if (_internal_has_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.status_;
    }
    clear_has_payload();
  }
}
inline ::Status* Wrapper::release_status() {
  // @@protoc_insertion_point(field_release:Wrapper.status)
  if (_internal_has_status()) {
    clear_has_payload();
    ::Status* temp = _impl_.payload_.status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Status& Wrapper::_internal_status() const {
  return _internal_has_status()
      ? *_impl_.payload_.status_
      : reinterpret_cast< ::Status&>(::_Status_default_instance_);
}
inline const ::Status& Wrapper::status() const {
  // @@protoc_insertion_point(field_get:Wrapper.status)
  return _internal_status();
}
inline ::Status* Wrapper::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Wrapper.status)
  if (_internal_has_status()) {
    clear_has_payload();
    ::Status* temp = _impl_.payload_.status_;
    _impl_.payload_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wrapper::unsafe_arena_set_allocated_status(::Status* status) {
  clear_payload();
  if (status) {
    set_has_status();
    _impl_.payload_.status_ = status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Wrapper.status)
}
inline ::Status* Wrapper::_internal_mutable_status() {
  if (!_internal_has_status()) {
    clear_payload();
    set_has_status();
    _impl_.payload_.status_ = CreateMaybeMessage< ::Status >(GetArenaForAllocation());
  }
  return _impl_.payload_.status_;
}
inline ::Status* Wrapper::mutable_status() {
  ::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:Wrapper.status)
  return _msg;
}

inline bool Wrapper::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Wrapper::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Wrapper::PayloadCase Wrapper::payload_case() const {
  return Wrapper::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignalServerConfigProto

// string sdf_directory = 1;
inline void SignalServerConfigProto::clear_sdf_directory() {
  _impl_.sdf_directory_.ClearToEmpty();
}
inline const std::string& SignalServerConfigProto::sdf_directory() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.sdf_directory)
  return _internal_sdf_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalServerConfigProto::set_sdf_directory(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdf_directory_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.sdf_directory)
}
inline std::string* SignalServerConfigProto::mutable_sdf_directory() {
  std::string* _s = _internal_mutable_sdf_directory();
  // @@protoc_insertion_point(field_mutable:SignalServerConfigProto.sdf_directory)
  return _s;
}
inline const std::string& SignalServerConfigProto::_internal_sdf_directory() const {
  return _impl_.sdf_directory_.Get();
}
inline void SignalServerConfigProto::_internal_set_sdf_directory(const std::string& value) {
  
  _impl_.sdf_directory_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::_internal_mutable_sdf_directory() {
  
  return _impl_.sdf_directory_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::release_sdf_directory() {
  // @@protoc_insertion_point(field_release:SignalServerConfigProto.sdf_directory)
  return _impl_.sdf_directory_.Release();
}
inline void SignalServerConfigProto::set_allocated_sdf_directory(std::string* sdf_directory) {
  if (sdf_directory != nullptr) {
    
  } else {
    
  }
  _impl_.sdf_directory_.SetAllocated(sdf_directory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdf_directory_.IsDefault()) {
    _impl_.sdf_directory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignalServerConfigProto.sdf_directory)
}

// string output_file = 2;
inline void SignalServerConfigProto::clear_output_file() {
  _impl_.output_file_.ClearToEmpty();
}
inline const std::string& SignalServerConfigProto::output_file() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.output_file)
  return _internal_output_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalServerConfigProto::set_output_file(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.output_file)
}
inline std::string* SignalServerConfigProto::mutable_output_file() {
  std::string* _s = _internal_mutable_output_file();
  // @@protoc_insertion_point(field_mutable:SignalServerConfigProto.output_file)
  return _s;
}
inline const std::string& SignalServerConfigProto::_internal_output_file() const {
  return _impl_.output_file_.Get();
}
inline void SignalServerConfigProto::_internal_set_output_file(const std::string& value) {
  
  _impl_.output_file_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::_internal_mutable_output_file() {
  
  return _impl_.output_file_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::release_output_file() {
  // @@protoc_insertion_point(field_release:SignalServerConfigProto.output_file)
  return _impl_.output_file_.Release();
}
inline void SignalServerConfigProto::set_allocated_output_file(std::string* output_file) {
  if (output_file != nullptr) {
    
  } else {
    
  }
  _impl_.output_file_.SetAllocated(output_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_file_.IsDefault()) {
    _impl_.output_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignalServerConfigProto.output_file)
}

// optional string user_terrain_file = 3;
inline bool SignalServerConfigProto::_internal_has_user_terrain_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_user_terrain_file() const {
  return _internal_has_user_terrain_file();
}
inline void SignalServerConfigProto::clear_user_terrain_file() {
  _impl_.user_terrain_file_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignalServerConfigProto::user_terrain_file() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.user_terrain_file)
  return _internal_user_terrain_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalServerConfigProto::set_user_terrain_file(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_terrain_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.user_terrain_file)
}
inline std::string* SignalServerConfigProto::mutable_user_terrain_file() {
  std::string* _s = _internal_mutable_user_terrain_file();
  // @@protoc_insertion_point(field_mutable:SignalServerConfigProto.user_terrain_file)
  return _s;
}
inline const std::string& SignalServerConfigProto::_internal_user_terrain_file() const {
  return _impl_.user_terrain_file_.Get();
}
inline void SignalServerConfigProto::_internal_set_user_terrain_file(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_terrain_file_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::_internal_mutable_user_terrain_file() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_terrain_file_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::release_user_terrain_file() {
  // @@protoc_insertion_point(field_release:SignalServerConfigProto.user_terrain_file)
  if (!_internal_has_user_terrain_file()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_terrain_file_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_terrain_file_.IsDefault()) {
    _impl_.user_terrain_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SignalServerConfigProto::set_allocated_user_terrain_file(std::string* user_terrain_file) {
  if (user_terrain_file != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_terrain_file_.SetAllocated(user_terrain_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_terrain_file_.IsDefault()) {
    _impl_.user_terrain_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignalServerConfigProto.user_terrain_file)
}

// optional string terrain_background = 4;
inline bool SignalServerConfigProto::_internal_has_terrain_background() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_terrain_background() const {
  return _internal_has_terrain_background();
}
inline void SignalServerConfigProto::clear_terrain_background() {
  _impl_.terrain_background_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignalServerConfigProto::terrain_background() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.terrain_background)
  return _internal_terrain_background();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalServerConfigProto::set_terrain_background(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.terrain_background_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.terrain_background)
}
inline std::string* SignalServerConfigProto::mutable_terrain_background() {
  std::string* _s = _internal_mutable_terrain_background();
  // @@protoc_insertion_point(field_mutable:SignalServerConfigProto.terrain_background)
  return _s;
}
inline const std::string& SignalServerConfigProto::_internal_terrain_background() const {
  return _impl_.terrain_background_.Get();
}
inline void SignalServerConfigProto::_internal_set_terrain_background(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.terrain_background_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::_internal_mutable_terrain_background() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.terrain_background_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalServerConfigProto::release_terrain_background() {
  // @@protoc_insertion_point(field_release:SignalServerConfigProto.terrain_background)
  if (!_internal_has_terrain_background()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.terrain_background_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.terrain_background_.IsDefault()) {
    _impl_.terrain_background_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SignalServerConfigProto::set_allocated_terrain_background(std::string* terrain_background) {
  if (terrain_background != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.terrain_background_.SetAllocated(terrain_background, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.terrain_background_.IsDefault()) {
    _impl_.terrain_background_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignalServerConfigProto.terrain_background)
}

// double latitude = 5;
inline void SignalServerConfigProto::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline double SignalServerConfigProto::_internal_latitude() const {
  return _impl_.latitude_;
}
inline double SignalServerConfigProto::latitude() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.latitude)
  return _internal_latitude();
}
inline void SignalServerConfigProto::_internal_set_latitude(double value) {
  
  _impl_.latitude_ = value;
}
inline void SignalServerConfigProto::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.latitude)
}

// double longitude = 6;
inline void SignalServerConfigProto::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline double SignalServerConfigProto::_internal_longitude() const {
  return _impl_.longitude_;
}
inline double SignalServerConfigProto::longitude() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.longitude)
  return _internal_longitude();
}
inline void SignalServerConfigProto::_internal_set_longitude(double value) {
  
  _impl_.longitude_ = value;
}
inline void SignalServerConfigProto::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.longitude)
}

// double tx_height = 7;
inline void SignalServerConfigProto::clear_tx_height() {
  _impl_.tx_height_ = 0;
}
inline double SignalServerConfigProto::_internal_tx_height() const {
  return _impl_.tx_height_;
}
inline double SignalServerConfigProto::tx_height() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.tx_height)
  return _internal_tx_height();
}
inline void SignalServerConfigProto::_internal_set_tx_height(double value) {
  
  _impl_.tx_height_ = value;
}
inline void SignalServerConfigProto::set_tx_height(double value) {
  _internal_set_tx_height(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.tx_height)
}

// repeated double rx_heights = 8;
inline int SignalServerConfigProto::_internal_rx_heights_size() const {
  return _impl_.rx_heights_.size();
}
inline int SignalServerConfigProto::rx_heights_size() const {
  return _internal_rx_heights_size();
}
inline void SignalServerConfigProto::clear_rx_heights() {
  _impl_.rx_heights_.Clear();
}
inline double SignalServerConfigProto::_internal_rx_heights(int index) const {
  return _impl_.rx_heights_.Get(index);
}
inline double SignalServerConfigProto::rx_heights(int index) const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.rx_heights)
  return _internal_rx_heights(index);
}
inline void SignalServerConfigProto::set_rx_heights(int index, double value) {
  _impl_.rx_heights_.Set(index, value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.rx_heights)
}
inline void SignalServerConfigProto::_internal_add_rx_heights(double value) {
  _impl_.rx_heights_.Add(value);
}
inline void SignalServerConfigProto::add_rx_heights(double value) {
  _internal_add_rx_heights(value);
  // @@protoc_insertion_point(field_add:SignalServerConfigProto.rx_heights)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SignalServerConfigProto::_internal_rx_heights() const {
  return _impl_.rx_heights_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SignalServerConfigProto::rx_heights() const {
  // @@protoc_insertion_point(field_list:SignalServerConfigProto.rx_heights)
  return _internal_rx_heights();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SignalServerConfigProto::_internal_mutable_rx_heights() {
  return &_impl_.rx_heights_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SignalServerConfigProto::mutable_rx_heights() {
  // @@protoc_insertion_point(field_mutable_list:SignalServerConfigProto.rx_heights)
  return _internal_mutable_rx_heights();
}

// double frequency_mhz = 9;
inline void SignalServerConfigProto::clear_frequency_mhz() {
  _impl_.frequency_mhz_ = 0;
}
inline double SignalServerConfigProto::_internal_frequency_mhz() const {
  return _impl_.frequency_mhz_;
}
inline double SignalServerConfigProto::frequency_mhz() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.frequency_mhz)
  return _internal_frequency_mhz();
}
inline void SignalServerConfigProto::_internal_set_frequency_mhz(double value) {
  
  _impl_.frequency_mhz_ = value;
}
inline void SignalServerConfigProto::set_frequency_mhz(double value) {
  _internal_set_frequency_mhz(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.frequency_mhz)
}

// double erp_watts = 10;
inline void SignalServerConfigProto::clear_erp_watts() {
  _impl_.erp_watts_ = 0;
}
inline double SignalServerConfigProto::_internal_erp_watts() const {
  return _impl_.erp_watts_;
}
inline double SignalServerConfigProto::erp_watts() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.erp_watts)
  return _internal_erp_watts();
}
inline void SignalServerConfigProto::_internal_set_erp_watts(double value) {
  
  _impl_.erp_watts_ = value;
}
inline void SignalServerConfigProto::set_erp_watts(double value) {
  _internal_set_erp_watts(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.erp_watts)
}

// optional double rx_threshold = 11;
inline bool SignalServerConfigProto::_internal_has_rx_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_rx_threshold() const {
  return _internal_has_rx_threshold();
}
inline void SignalServerConfigProto::clear_rx_threshold() {
  _impl_.rx_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double SignalServerConfigProto::_internal_rx_threshold() const {
  return _impl_.rx_threshold_;
}
inline double SignalServerConfigProto::rx_threshold() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.rx_threshold)
  return _internal_rx_threshold();
}
inline void SignalServerConfigProto::_internal_set_rx_threshold(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rx_threshold_ = value;
}
inline void SignalServerConfigProto::set_rx_threshold(double value) {
  _internal_set_rx_threshold(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.rx_threshold)
}

// optional bool horizontal_pol = 12;
inline bool SignalServerConfigProto::_internal_has_horizontal_pol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_horizontal_pol() const {
  return _internal_has_horizontal_pol();
}
inline void SignalServerConfigProto::clear_horizontal_pol() {
  _impl_.horizontal_pol_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool SignalServerConfigProto::_internal_horizontal_pol() const {
  return _impl_.horizontal_pol_;
}
inline bool SignalServerConfigProto::horizontal_pol() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.horizontal_pol)
  return _internal_horizontal_pol();
}
inline void SignalServerConfigProto::_internal_set_horizontal_pol(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.horizontal_pol_ = value;
}
inline void SignalServerConfigProto::set_horizontal_pol(bool value) {
  _internal_set_horizontal_pol(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.horizontal_pol)
}

// optional double ground_clutter = 13;
inline bool SignalServerConfigProto::_internal_has_ground_clutter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_ground_clutter() const {
  return _internal_has_ground_clutter();
}
inline void SignalServerConfigProto::clear_ground_clutter() {
  _impl_.ground_clutter_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double SignalServerConfigProto::_internal_ground_clutter() const {
  return _impl_.ground_clutter_;
}
inline double SignalServerConfigProto::ground_clutter() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.ground_clutter)
  return _internal_ground_clutter();
}
inline void SignalServerConfigProto::_internal_set_ground_clutter(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ground_clutter_ = value;
}
inline void SignalServerConfigProto::set_ground_clutter(double value) {
  _internal_set_ground_clutter(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.ground_clutter)
}

// optional int32 terrain_code = 14;
inline bool SignalServerConfigProto::_internal_has_terrain_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_terrain_code() const {
  return _internal_has_terrain_code();
}
inline void SignalServerConfigProto::clear_terrain_code() {
  _impl_.terrain_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t SignalServerConfigProto::_internal_terrain_code() const {
  return _impl_.terrain_code_;
}
inline int32_t SignalServerConfigProto::terrain_code() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.terrain_code)
  return _internal_terrain_code();
}
inline void SignalServerConfigProto::_internal_set_terrain_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.terrain_code_ = value;
}
inline void SignalServerConfigProto::set_terrain_code(int32_t value) {
  _internal_set_terrain_code(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.terrain_code)
}

// optional double terrain_dielectric = 15;
inline bool SignalServerConfigProto::_internal_has_terrain_dielectric() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_terrain_dielectric() const {
  return _internal_has_terrain_dielectric();
}
inline void SignalServerConfigProto::clear_terrain_dielectric() {
  _impl_.terrain_dielectric_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double SignalServerConfigProto::_internal_terrain_dielectric() const {
  return _impl_.terrain_dielectric_;
}
inline double SignalServerConfigProto::terrain_dielectric() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.terrain_dielectric)
  return _internal_terrain_dielectric();
}
inline void SignalServerConfigProto::_internal_set_terrain_dielectric(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.terrain_dielectric_ = value;
}
inline void SignalServerConfigProto::set_terrain_dielectric(double value) {
  _internal_set_terrain_dielectric(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.terrain_dielectric)
}

// optional double terrain_conductivity = 16;
inline bool SignalServerConfigProto::_internal_has_terrain_conductivity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_terrain_conductivity() const {
  return _internal_has_terrain_conductivity();
}
inline void SignalServerConfigProto::clear_terrain_conductivity() {
  _impl_.terrain_conductivity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double SignalServerConfigProto::_internal_terrain_conductivity() const {
  return _impl_.terrain_conductivity_;
}
inline double SignalServerConfigProto::terrain_conductivity() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.terrain_conductivity)
  return _internal_terrain_conductivity();
}
inline void SignalServerConfigProto::_internal_set_terrain_conductivity(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.terrain_conductivity_ = value;
}
inline void SignalServerConfigProto::set_terrain_conductivity(double value) {
  _internal_set_terrain_conductivity(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.terrain_conductivity)
}

// optional int32 climate_code = 17;
inline bool SignalServerConfigProto::_internal_has_climate_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_climate_code() const {
  return _internal_has_climate_code();
}
inline void SignalServerConfigProto::clear_climate_code() {
  _impl_.climate_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t SignalServerConfigProto::_internal_climate_code() const {
  return _impl_.climate_code_;
}
inline int32_t SignalServerConfigProto::climate_code() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.climate_code)
  return _internal_climate_code();
}
inline void SignalServerConfigProto::_internal_set_climate_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.climate_code_ = value;
}
inline void SignalServerConfigProto::set_climate_code(int32_t value) {
  _internal_set_climate_code(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.climate_code)
}

// int32 propagation_model = 18;
inline void SignalServerConfigProto::clear_propagation_model() {
  _impl_.propagation_model_ = 0;
}
inline int32_t SignalServerConfigProto::_internal_propagation_model() const {
  return _impl_.propagation_model_;
}
inline int32_t SignalServerConfigProto::propagation_model() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.propagation_model)
  return _internal_propagation_model();
}
inline void SignalServerConfigProto::_internal_set_propagation_model(int32_t value) {
  
  _impl_.propagation_model_ = value;
}
inline void SignalServerConfigProto::set_propagation_model(int32_t value) {
  _internal_set_propagation_model(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.propagation_model)
}

// optional bool knife_edge_diff = 19;
inline bool SignalServerConfigProto::_internal_has_knife_edge_diff() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_knife_edge_diff() const {
  return _internal_has_knife_edge_diff();
}
inline void SignalServerConfigProto::clear_knife_edge_diff() {
  _impl_.knife_edge_diff_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool SignalServerConfigProto::_internal_knife_edge_diff() const {
  return _impl_.knife_edge_diff_;
}
inline bool SignalServerConfigProto::knife_edge_diff() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.knife_edge_diff)
  return _internal_knife_edge_diff();
}
inline void SignalServerConfigProto::_internal_set_knife_edge_diff(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.knife_edge_diff_ = value;
}
inline void SignalServerConfigProto::set_knife_edge_diff(bool value) {
  _internal_set_knife_edge_diff(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.knife_edge_diff)
}

// optional bool win32_tile_names = 20;
inline bool SignalServerConfigProto::_internal_has_win32_tile_names() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_win32_tile_names() const {
  return _internal_has_win32_tile_names();
}
inline void SignalServerConfigProto::clear_win32_tile_names() {
  _impl_.win32_tile_names_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool SignalServerConfigProto::_internal_win32_tile_names() const {
  return _impl_.win32_tile_names_;
}
inline bool SignalServerConfigProto::win32_tile_names() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.win32_tile_names)
  return _internal_win32_tile_names();
}
inline void SignalServerConfigProto::_internal_set_win32_tile_names(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.win32_tile_names_ = value;
}
inline void SignalServerConfigProto::set_win32_tile_names(bool value) {
  _internal_set_win32_tile_names(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.win32_tile_names)
}

// optional bool debug_mode = 21;
inline bool SignalServerConfigProto::_internal_has_debug_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_debug_mode() const {
  return _internal_has_debug_mode();
}
inline void SignalServerConfigProto::clear_debug_mode() {
  _impl_.debug_mode_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool SignalServerConfigProto::_internal_debug_mode() const {
  return _impl_.debug_mode_;
}
inline bool SignalServerConfigProto::debug_mode() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.debug_mode)
  return _internal_debug_mode();
}
inline void SignalServerConfigProto::_internal_set_debug_mode(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.debug_mode_ = value;
}
inline void SignalServerConfigProto::set_debug_mode(bool value) {
  _internal_set_debug_mode(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.debug_mode)
}

// optional bool metric_units = 22;
inline bool SignalServerConfigProto::_internal_has_metric_units() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_metric_units() const {
  return _internal_has_metric_units();
}
inline void SignalServerConfigProto::clear_metric_units() {
  _impl_.metric_units_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool SignalServerConfigProto::_internal_metric_units() const {
  return _impl_.metric_units_;
}
inline bool SignalServerConfigProto::metric_units() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.metric_units)
  return _internal_metric_units();
}
inline void SignalServerConfigProto::_internal_set_metric_units(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.metric_units_ = value;
}
inline void SignalServerConfigProto::set_metric_units(bool value) {
  _internal_set_metric_units(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.metric_units)
}

// optional bool plot_dbm = 23;
inline bool SignalServerConfigProto::_internal_has_plot_dbm() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool SignalServerConfigProto::has_plot_dbm() const {
  return _internal_has_plot_dbm();
}
inline void SignalServerConfigProto::clear_plot_dbm() {
  _impl_.plot_dbm_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool SignalServerConfigProto::_internal_plot_dbm() const {
  return _impl_.plot_dbm_;
}
inline bool SignalServerConfigProto::plot_dbm() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.plot_dbm)
  return _internal_plot_dbm();
}
inline void SignalServerConfigProto::_internal_set_plot_dbm(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.plot_dbm_ = value;
}
inline void SignalServerConfigProto::set_plot_dbm(bool value) {
  _internal_set_plot_dbm(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.plot_dbm)
}

// double radius = 24;
inline void SignalServerConfigProto::clear_radius() {
  _impl_.radius_ = 0;
}
inline double SignalServerConfigProto::_internal_radius() const {
  return _impl_.radius_;
}
inline double SignalServerConfigProto::radius() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.radius)
  return _internal_radius();
}
inline void SignalServerConfigProto::_internal_set_radius(double value) {
  
  _impl_.radius_ = value;
}
inline void SignalServerConfigProto::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.radius)
}

// int32 resolution = 25;
inline void SignalServerConfigProto::clear_resolution() {
  _impl_.resolution_ = 0;
}
inline int32_t SignalServerConfigProto::_internal_resolution() const {
  return _impl_.resolution_;
}
inline int32_t SignalServerConfigProto::resolution() const {
  // @@protoc_insertion_point(field_get:SignalServerConfigProto.resolution)
  return _internal_resolution();
}
inline void SignalServerConfigProto::_internal_set_resolution(int32_t value) {
  
  _impl_.resolution_ = value;
}
inline void SignalServerConfigProto::set_resolution(int32_t value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:SignalServerConfigProto.resolution)
}

// -------------------------------------------------------------------

// Status

// string type_status = 1;
inline void Status::clear_type_status() {
  _impl_.type_status_.ClearToEmpty();
}
inline const std::string& Status::type_status() const {
  // @@protoc_insertion_point(field_get:Status.type_status)
  return _internal_type_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_type_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Status.type_status)
}
inline std::string* Status::mutable_type_status() {
  std::string* _s = _internal_mutable_type_status();
  // @@protoc_insertion_point(field_mutable:Status.type_status)
  return _s;
}
inline const std::string& Status::_internal_type_status() const {
  return _impl_.type_status_.Get();
}
inline void Status::_internal_set_type_status(const std::string& value) {
  
  _impl_.type_status_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_type_status() {
  
  return _impl_.type_status_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_type_status() {
  // @@protoc_insertion_point(field_release:Status.type_status)
  return _impl_.type_status_.Release();
}
inline void Status::set_allocated_type_status(std::string* type_status) {
  if (type_status != nullptr) {
    
  } else {
    
  }
  _impl_.type_status_.SetAllocated(type_status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_status_.IsDefault()) {
    _impl_.type_status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Status.type_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_5falgo_2eproto
